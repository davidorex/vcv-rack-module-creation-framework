# DSP Architecture: [ModuleName]

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, voltage standards, and VCV Rack integration

---

## Core Components

[For each DSP component, create a subsection with this structure:]

### [Component Name]

- **VCV DSP Class:** `rack::dsp::ClassName` or "Custom implementation (description)"
- **Purpose:** [What this component does]
- **Parameters Affected:** [List parameter IDs that control this component]
- **CV Inputs Affected:** [List CV input IDs that modulate this component]
- **Configuration:**
  - [Specific settings, ranges, formulas]
  - [Initialization parameters]
  - [Any special handling]

**Example:**
```markdown
### Delay Line

- **VCV DSP Class:** `rack::dsp::DoubleRingBuffer<float, 16>` (custom delay implementation)
- **Purpose:** Variable-length delay buffer with interpolated read for smooth pitch-shifting
- **Parameters Affected:** TIME, FEEDBACK, MIX
- **CV Inputs Affected:** TIME_CV, FEEDBACK_CV
- **Configuration:**
  - Buffer size: 1 second at 192kHz = 192,000 samples (worst case)
  - Interpolation: Cubic interpolation for smooth pitch-shifting
  - Write position: Advanced by 1 sample per process() call
  - Read position: Calculated from TIME param + TIME_CV input
  - Formula: `readPos = writePos - (delayTime * sampleRate)`
```

**Example:**
```markdown
### Tape Saturation

- **VCV DSP Class:** Custom implementation (soft clipper with oversampling)
- **Purpose:** Emulate tape compression and harmonic generation in feedback path
- **Parameters Affected:** FEEDBACK (drives saturation amount)
- **CV Inputs Affected:** None (follows feedback level)
- **Configuration:**
  - Algorithm: Hyperbolic tangent waveshaping `tanh(gain * x)`
  - Gain staging: `gain = 1.0 + (feedback - 0.8) * 5.0` when feedback > 80%
  - Oversampling: 2x to reduce aliasing from nonlinear process
  - Applied after delay read, before feedback write
```

---

## Processing Chain

[ASCII diagram showing signal flow, parameter connections, and CV routing]

**Example:**
```
Input (Audio/CV Port)
  ↓
  ├─────────────────────┐ (Dry path to DRY output)
  ↓                     ↓
Gain Stage          DRY Output
(Input level)
  ↓
Write to Delay Buffer ← FEEDBACK (internal feedback)
  ↑                     ↑
  │                   EXT FB Input (external feedback)
  │                     │
  └─────────────────────┘ (feedback loop)
  ↓
Read from Delay Buffer ← TIME param + TIME_CV input
  ↓                       (interpolated read position)
Tone Filter ← TONE param
  ↓
Tape Saturation ← FEEDBACK level
  ↓
Feedback Mixer ← FEEDBACK param + FEEDBACK_CV input
  ↓
Ping-Pong Router ← PING-PONG switch
  ↓
  ├───────────────────┐
  ↓                   ↓
Dry/Wet Mix       Dry/Wet Mix
(Left)            (Right)
  ↓                   ↓
OUT L             OUT R
```

**Routing notes:**
- Input signal splits to dry path (DRY output) and wet path (delay buffer write)
- Delay read position calculated from TIME + TIME_CV (clamped to 10ms-1s range)
- TONE filter only affects feedback path (not initial wet signal)
- FEEDBACK mixer uses EXT FB input if patched, otherwise uses internal feedback
- PING-PONG switch routes delays alternately to L/R outputs when enabled
- MIX param controls dry/wet balance at output stage

**Conditional routing:**
- If EXT FB patched → use EXT FB input instead of internal feedback
- If PING-PONG enabled → alternate delays between L/R, otherwise L=R (mono)
- If FREEZE gate high → stop writing to buffer, continue reading (infinite sustain)

**Polyphonic routing:**
- Each channel (1-16) gets independent delay buffer and processing chain
- TIME/FEEDBACK CV can be polyphonic (per-channel control) or monophonic (global)
- OUTPUT channel count matches INPUT channel count

---

## Parameter Mapping

[Table mapping every parameter ID to DSP component and usage]

| Parameter ID | Type | Range | DSP Component | Usage | Formula/Mapping |
|-------------|------|-------|---------------|-------|-----------------|
| [PARAM_NAME] | Float/Bool | [Min-Max] | [Component] | [Description] | [Math formula] |

**Example:**
```markdown
| Parameter ID | Type | Range | DSP Component | Usage | Formula/Mapping |
|-------------|------|-------|---------------|-------|-----------------|
| TIME | Float | 10ms - 1s | Delay Line | Delay time (read position offset) | `readPos = writePos - (time * sampleRate)` |
| FEEDBACK | Float | 0 - 120% | Feedback Mixer | Feedback gain (0.0-1.2) | `feedbackGain = value / 100.0` |
| MIX | Float | 0 - 100% | Output Mixer | Dry/wet balance | `wet = value / 100.0; dry = 1.0 - wet` |
| TONE | Float | -100 to +100 | Tone Filter | Filter cutoff (LP/HP) | Negative = LP (500Hz-5kHz), Positive = HP (100Hz-2kHz) |
| WOW | Float | 0 - 100% | LFO (slow) | Slow tape speed variation | `depth = value / 100.0 * 0.02` (±2% max) |
| FLUTTER | Float | 0 - 100% | LFO (fast) | Fast tape speed variation | `depth = value / 100.0 * 0.01` (±1% max) |
| PING_PONG | Bool | 0/1 | Routing | Stereo ping-pong toggle | 0 = mono (L=R), 1 = alternate L/R |
```

---

## CV Input Mapping

[Table mapping CV inputs to DSP components and voltage ranges]

| CV Input ID | Voltage Range | DSP Component | Usage | Scaling Formula |
|------------|--------------|---------------|-------|-----------------|
| [INPUT_NAME] | [Range] | [Component] | [Description] | [Math formula] |

**Example:**
```markdown
| CV Input ID | Voltage Range | DSP Component | Usage | Scaling Formula |
|------------|--------------|---------------|-------|-----------------|
| TIME_CV | ±5V | Delay Line | Modulate delay time | `time += cv * 0.1s` (1V = 100ms shift) |
| FEEDBACK_CV | ±5V | Feedback Mixer | Modulate feedback amount | `fb += cv * 0.2` (1V = 20% shift) |
| FREEZE | 0-10V (gate) | Delay Line | Freeze buffer writes | High (>1V) = freeze, Low = normal |
| EXT_FB | ±5V (audio) | Feedback Mixer | External feedback input | Replaces internal feedback when patched |
```

**CV Input Behavior:**
- **TIME_CV**: Added to TIME param, clamped to 10ms-1s range. When FEEDBACK = 100%, tracks 1V/oct for pitched resonance.
- **FEEDBACK_CV**: Bipolar modulation, added to FEEDBACK param, clamped to 0-120% range.
- **FREEZE**: Gate input, rising edge freezes buffer, falling edge resumes. High state maintains infinite sustain.
- **EXT_FB**: Audio input, normalized to internal feedback. When patched, breaks internal feedback path.

---

## Voltage Standards

### Input Voltage Ranges

[Define expected voltage ranges for all inputs]

| Input | Standard | Accepted Range | Behavior Outside Range | Notes |
|-------|----------|----------------|----------------------|-------|
| [Name] | [Typical] | [Min-Max] | [Clipping/Wrapping] | [Special notes] |

**Example:**
```markdown
| Input | Standard | Accepted Range | Behavior Outside Range | Notes |
|-------|----------|----------------|----------------------|-------|
| IN (audio) | ±5V | ±10V | Soft clipping at ±10V | Saturation stage limits extreme signals |
| TIME_CV | ±5V | ±10V | Clamped to 10ms-1s output | Excessive CV limited to delay time range |
| FEEDBACK_CV | ±5V | ±10V | Clamped to 0-120% | Feedback limited to prevent runaway |
| FREEZE (gate) | 10V | 0-10V | >1V = high, <1V = low | Schmitt trigger (0.5V hysteresis) |
| EXT_FB (audio) | ±5V | ±10V | Soft clipping at ±10V | Same path as internal feedback |
```

### Output Voltage Ranges

[Define generated voltage ranges for all outputs]

| Output | Standard | Generated Range | Polarity | Notes |
|--------|----------|----------------|----------|-------|
| [Name] | [Typical] | [Min-Max] | [Bipolar/Unipolar] | [Special notes] |

**Example:**
```markdown
| Output | Standard | Generated Range | Polarity | Notes |
|--------|----------|----------------|----------|-------|
| OUT L | ±5V | ±5V (soft clip ±6V) | Bipolar | Audio output, left/mono |
| OUT R | ±5V | ±5V (soft clip ±6V) | Bipolar | Audio output, right (copy of L if ping-pong off) |
| DRY | ±5V | ±5V (matches input) | Bipolar | Buffered input for parallel processing |
```

### Pitch CV Standards (if applicable)

[If module uses 1V/oct pitch tracking]

**Example:**
```markdown
**Pitch CV Standard:** 1V/oct

**Usage:** When FEEDBACK = 100%, self-oscillation tracks 1V/oct CV on TIME_CV input.

**Implementation:**
- Base frequency (C4 = 0V): `freq = dsp::FREQ_C4` (261.63 Hz)
- CV to frequency: `freq = FREQ_C4 * dsp::exp2_taylor5(pitchCV)`
- Frequency to delay time: `delayTime = 1.0 / freq`
- Applied after TIME param (param sets coarse, CV sets fine/tracking)

**Validation:**
- 0V → C4 (261.63 Hz) → 3.82ms delay
- 1V → C5 (523.25 Hz) → 1.91ms delay
- -1V → C3 (130.81 Hz) → 7.64ms delay

**Notes:**
- Only active when FEEDBACK ≥ 90% (resonance must be audible)
- TIME param becomes coarse tuning, CV becomes fine tuning
- Works with keyboard/sequencer CV outputs
```

---

## Algorithm Details

[For each algorithm/component, describe the implementation approach]

### [Component Name]

**Algorithm:** [Mathematical description or processing approach]

**Implementation notes:**
- [Key formulas]
- [Coefficient calculation]
- [Interpolation method]
- [Edge case handling]

**Example:**
```markdown
### Interpolated Delay Line

**Algorithm:** Cubic interpolation for fractional sample delay

**Implementation notes:**
- Buffer: Circular buffer using `rack::dsp::DoubleRingBuffer<float, 16>` (16 = max channels)
- Write: Simple append to buffer, advance write head
- Read: Fractional read position using cubic interpolation
  - Formula: `y = cubic(y0, y1, y2, y3, frac)` where frac = fractional part of read position
  - Requires 4-sample neighborhood (y0, y1, y2, y3)
- Delay time modulation: Smooth changes over 10ms to prevent clicks
  - Use one-pole lowpass filter on delay time: `time = time + alpha * (target - time)`
  - Alpha = `1.0 - exp(-2.0 * pi * 50Hz / sampleRate)` (50Hz cutoff)
- Buffer size: 1 second at 192kHz = 192,000 samples per channel
  - Total memory: 192,000 samples × 16 channels × 4 bytes = ~12 MB worst case
```

**Example:**
```markdown
### Tape Saturation

**Algorithm:** Oversampled hyperbolic tangent waveshaping

**Implementation notes:**
- Transfer function: `output = tanh(gain * input)` where gain depends on feedback level
- Gain staging:
  - Below 80% feedback: `gain = 1.0` (unity, no saturation)
  - Above 80% feedback: `gain = 1.0 + (feedback - 0.8) * 5.0` (ramps to 2.0 at 100%)
- Oversampling: 2x (88.2kHz / 96kHz / 384kHz depending on base rate)
  - Upsample: Linear interpolation (cheap, sufficient for 2x)
  - Process: Apply tanh() at high sample rate
  - Downsample: `rack::dsp::Decimator<2, 8>` (8th-order brickwall filter)
- Applied after delay read, before feedback write (in feedback path only)
```

**Example:**
```markdown
### Tone Filter (Feedback Path)

**Algorithm:** State-variable filter (lowpass/highpass switchable)

**Implementation notes:**
- Filter type: `rack::dsp::TStateVariableFilter<float>` (TPT structure, stable)
- Mode: TONE < 0 = lowpass, TONE > 0 = highpass, TONE ≈ 0 = bypass (within ±0.5%)
- Cutoff mapping:
  - Lowpass (TONE -100 to 0): `cutoff = 500Hz + (abs(tone) / 100.0) * 4500Hz` (500Hz-5kHz)
  - Highpass (TONE 0 to +100): `cutoff = 100Hz + (tone / 100.0) * 1900Hz` (100Hz-2kHz)
- Resonance: Fixed at Q = 0.707 (Butterworth, no resonance peak)
- Update rate: Per-sample (smooth parameter changes, no zipper noise)
- Bypass zone: |TONE| < 0.5% → bypass filter (prevent accidental filtering at center)
```

**Example:**
```markdown
### Wow/Flutter Modulation

**Algorithm:** Dual LFO with random waveform for tape speed variation

**Implementation notes:**
- Two independent LFOs: WOW (slow, 0.1-0.5 Hz) and FLUTTER (fast, 1-5 Hz)
- Waveform: Smoothed random (sample & hold + one-pole lowpass)
  - Random value: `rack::random::uniform()` (0.0-1.0) sampled at LFO rate
  - Lowpass: `smoothed = smoothed + alpha * (random - smoothed)` (alpha = 0.1)
  - Result: Smooth, organic waveform (not stepped)
- Depth scaling:
  - WOW: 0-100% param → 0-2% delay time modulation
  - FLUTTER: 0-100% param → 0-1% delay time modulation
- Applied to delay time: `time = baseTime * (1.0 + wow + flutter)`
- Phase: Independent per channel (polyphonic), continuous (no resets)
```

---

## Polyphony Strategy

### Channel Processing

**Mode:** [Monophonic | Fully Polyphonic | Sum to Mono | Polyphonic Passthrough]

**Description:** [How module handles polyphonic cables and per-channel state]

**Example:**
```markdown
**Mode:** Fully Polyphonic

**Description:**
- Input (IN) port determines active channel count (1-16)
- Each channel gets independent delay buffer and processing chain
- TIME_CV and FEEDBACK_CV can be polyphonic (per-channel control) or monophonic (broadcast)
- Output channel count matches input channel count
- Total memory scales with channel count (12 MB / 16 = 750 KB per channel)
```

### Per-Channel State

[What state is maintained per channel vs shared]

**Example:**
```markdown
**Per-Channel State:**
- Delay buffer (192,000 samples × 4 bytes = 750 KB per channel)
- Write head position (independent for each channel)
- Read head position (calculated per channel from TIME + TIME_CV[channel])
- Filter state (lowpass/highpass for TONE)
- Saturation state (oversampling buffers)
- LFO phase (wow/flutter, independent per channel for organic variation)

**Shared State:**
- Parameters (TIME, FEEDBACK, MIX, TONE, WOW, FLUTTER, PING_PONG)
- LFO frequencies (all channels use same wow/flutter rate, different phases)
- Sample rate, buffer size (global settings)
```

### Channel Iteration

[How process() loop handles multiple channels]

**Example:**
```markdown
void process(const ProcessArgs& args) override {
    // Determine active channels
    int channels = std::max(1, inputs[IN_INPUT].getChannels());

    // Update global state (parameters, LFO frequencies)
    updateGlobalState(args);

    // Process each channel independently
    for (int c = 0; c < channels; c++) {
        // Get input for this channel
        float input = inputs[IN_INPUT].getVoltage(c);

        // Get CV for this channel (polyphonic or broadcast)
        float timeCv = inputs[TIME_CV_INPUT].getPolyVoltage(c);
        float feedbackCv = inputs[FEEDBACK_CV_INPUT].getPolyVoltage(c);

        // Process this channel
        float output = processChannel(c, input, timeCv, feedbackCv);

        // Set output for this channel
        outputs[OUT_L_OUTPUT].setVoltage(output, c);
        outputs[OUT_R_OUTPUT].setVoltage(output, c);  // Modified if ping-pong
    }

    // Set output channel counts
    outputs[OUT_L_OUTPUT].setChannels(channels);
    outputs[OUT_R_OUTPUT].setChannels(channels);
    outputs[DRY_OUTPUT].setChannels(channels);
}
```

### SIMD Optimization (Optional)

[If using float_4 for performance]

**Example:**
```markdown
**SIMD Processing:** Process 4 channels at once using `float_4`

```cpp
// Process in groups of 4
for (int c = 0; c < channels; c += 4) {
    // Load 4 channels at once
    float_4 input = inputs[IN_INPUT].getPolyVoltageSimd<float_4>(c);
    float_4 timeCv = inputs[TIME_CV_INPUT].getPolyVoltageSimd<float_4>(c);

    // Process 4 channels in parallel (SIMD operations)
    float_4 output = processChannelSimd(c, input, timeCv);

    // Store 4 channels at once
    outputs[OUT_L_OUTPUT].setVoltageSimd(output, c);
}
```

**Performance benefit:** 2-4x speedup for polyphonic processing (CPU-dependent)

**Tradeoff:** More complex code, requires SIMD-aware DSP (filters, interpolation)
```

---

## Special Considerations

### Thread Safety

[Parameter access patterns, concurrency, lock-free updates]

**Example:**
```markdown
- **Module::process()** is mutually exclusive with **dataToJson/dataFromJson** (guaranteed by VCV Rack)
- No mutexes needed within Module class methods
- Parameter reads are thread-safe (Rack guarantees atomic access)
- UI callbacks (ModuleWidget) run in separate thread:
  - Use `params[X].getValue()` for safe reads
  - Use `params[X].setValue()` for safe writes (Rack handles synchronization)
- Large state changes (buffer resizes) must be handled carefully:
  - Allocate new buffer in UI thread
  - Swap pointer atomically or pause engine temporarily
```

### Performance

[CPU usage estimates, hot paths, optimization opportunities]

**Example:**
```markdown
**CPU Budget Estimates:**
- Monophonic (1 channel): 1-2% CPU
  - Delay read/write: 0.5%
  - Cubic interpolation: 0.3%
  - Tone filter: 0.2%
  - Saturation (2x oversample): 0.5%
  - Mixing/routing: 0.2%
- 16-channel polyphonic: 8-12% CPU
  - Scales linearly with channel count
  - Each channel is independent (no shared computation)

**Hot Paths:**
- Cubic interpolation in delay read (called per sample, per channel)
- Oversampled saturation (2x samples processed)
- Tone filter update (per sample, per channel)

**Optimization Opportunities:**
- Use SIMD (float_4) for 2-4x speedup on polyphonic processing
- Reduce interpolation quality (linear instead of cubic) if CPU-constrained
- Skip tone filter if TONE ≈ 0 (bypass mode)
- Skip saturation if FEEDBACK < 80% (no saturation applied)
- Reduce oversampling to 1x (no oversampling) if CPU budget tight

**Profiling:**
- Use VCV Rack performance monitor (View → Frame rate)
- Target: <1% CPU per active channel
- Test with 16-channel polyphonic input at 192kHz (worst case)
```

### Denormal Protection

[How denormals are handled to prevent CPU spikes]

**Example:**
```markdown
**Denormal Handling:**
- VCV Rack automatically adds `_MM_SET_FLUSH_ZERO_MODE` (flush denormals to zero)
- No manual denormal protection needed in process()
- Delay buffer silence: Add small DC offset (1e-10) to prevent denormals in feedback path
- Filter state: rack::dsp filters handle denormals internally (no action needed)
- LFO phase: Use fmod() or wrap phase to prevent denormals in phase accumulator

**Example code:**
```cpp
// Add tiny DC offset to prevent denormals in feedback path
float feedback = feedbackSignal + 1e-10f;
```
```

### Sample Rate Handling

[Sample rate dependent calculations, coefficient recalculation]

**Example:**
```markdown
**Sample Rate Changes:**
- VCV Rack calls `onSampleRateChange()` when audio engine sample rate changes
- Must recalculate sample-rate-dependent values:

**Recalculate on sample rate change:**
- Delay buffer size: `bufferSize = maxDelayTime * sampleRate`
- Filter coefficients: Tone filter cutoff depends on sampleRate
- LFO phase increment: `phaseInc = lfoFreq / sampleRate`
- Time smoothing filter: `alpha = 1.0 - exp(-2pi * cutoff / sampleRate)`
- Oversampling factor: Fixed at 2x (but internal rate changes)

**Implementation:**
```cpp
void onSampleRateChange(const SampleRateChangeEvent& e) override {
    float sr = e.sampleRate;

    // Resize delay buffers
    for (int c = 0; c < 16; c++) {
        delayBuffers[c].resize(sr * 1.0);  // 1 second at new rate
    }

    // Update filter sample rate
    toneFilter.setSampleRate(sr);

    // Update LFO phase increments
    wowLfo.setFrequency(wowFreq, sr);
    flutterLfo.setFrequency(flutterFreq, sr);

    // Update smoothing filter
    timeSmoothAlpha = 1.0 - exp(-2.0 * M_PI * 50.0 / sr);
}
```
```

### Latency

[Processing latency sources, host compensation]

**Example:**
```markdown
**Latency Sources:**
- Base delay: Variable (10ms-1s depending on TIME param) - unavoidable, this is the effect
- Oversampling: 2x oversampling adds ~8 samples latency (decimation filter delay)
  - At 48kHz: 8 samples = 0.17ms (negligible)
  - At 192kHz: 8 samples = 0.04ms (negligible)
- No lookahead required (causal processing)

**Total Latency:**
- ~8 samples from oversampling (constant)
- Delay time is not considered "latency" (it's the intended effect)

**Host Compensation:**
- VCV Rack does not have plugin delay compensation (unlike DAWs)
- No need to report latency via API
- Oversampling latency (~8 samples) is negligible and not reported

**Notes:**
- DRY output is not latency-compensated (immediate passthrough)
- Users can manually delay DRY signal if exact phase alignment needed
```

### Memory Usage

[Buffer allocation, memory scaling with polyphony]

**Example:**
```markdown
**Memory Breakdown:**

**Per-Channel:**
- Delay buffer: 192,000 samples × 4 bytes = 768 KB (1 second at 192kHz)
- Oversampling buffers: 2x × 1024 samples × 4 bytes = 8 KB
- Filter state: ~100 bytes (negligible)
- LFO state: ~100 bytes (negligible)
- **Total per channel:** ~780 KB

**Polyphonic Scaling:**
- 1 channel: 780 KB
- 4 channels: 3.1 MB
- 8 channels: 6.2 MB
- 16 channels: 12.5 MB

**Optimization:**
- Allocate buffers lazily (only when channel is active)
- Deallocate unused channel buffers after 1 second of silence
- Alternative: Use shorter buffer (500ms max) to halve memory usage

**Validation:**
- 12.5 MB for 16 channels is acceptable on modern systems
- Rack users with 32 GB RAM can run ~2500 instances (unrealistic)
- More likely CPU-bound before memory-bound
```

---

## Research References

### Professional Modules

[List 3-5 VCV Rack or hardware Eurorack modules researched, with observations]

**Example:**
```markdown
1. **VCV Delay** (VCV)
   - Implementation: Uses `dsp::DoubleRingBuffer` for delay line
   - Observed: Clean, transparent delay with no coloration
   - Notes: Good reference for basic delay structure
   - Code: Open source (rack/src/dsp.cpp)

2. **Chronoblob2** (Alright Devices)
   - Implementation: External feedback input for creative patching
   - Observed: Supports feedback path interruption for filter insertion
   - Notes: Use normalization pattern (internal feedback if not patched)

3. **Echophon** (Synthesis Technology / VCV)
   - Implementation: Voltage-controlled feedback, self-oscillation at max feedback
   - Observed: Smooth pitch tracking when used as resonator
   - Notes: Implement 1V/oct tracking when feedback ≥ 90%

4. **Befaco Spring Reverb** (VCV)
   - Implementation: Polyphonic processing with per-channel state
   - Observed: Efficient SIMD processing for 16 channels
   - Notes: Use `getPolyVoltageSimd<float_4>` for 4-channel batching

5. **Vult Tangents** (Vult)
   - Implementation: Oversampled distortion (2x-4x)
   - Observed: Uses `dsp::Decimator` for anti-aliased nonlinear processing
   - Notes: Good reference for tape saturation implementation
```

### VCV Rack DSP Documentation

[Document VCV Rack classes researched and key findings]

**Example:**
```markdown
- **rack::dsp::DoubleRingBuffer**: Lock-free ring buffer for delay lines
  - Used for variable-length delays
  - Supports arbitrary read positions (interpolation required)
  - Thread-safe (lock-free push/pop)

- **rack::dsp::TStateVariableFilter**: TPT state-variable filter (stable)
  - Supports lowpass, highpass, bandpass modes
  - Stable at all frequencies (0Hz to Nyquist)
  - Smooth parameter changes (no zipper noise)

- **rack::dsp::Decimator**: Oversampling/downsampling for anti-aliasing
  - Implements brickwall lowpass filter for downsampling
  - Configurable oversampling factor (2x, 4x, 8x, etc.)
  - Zero-phase FIR filter (no phase distortion)

- **rack::dsp::exp2_taylor5()**: Fast exponential approximation
  - Used for 1V/oct pitch CV → frequency conversion
  - Formula: `freq = FREQ_C4 * exp2_taylor5(pitchCV)`
  - ~5x faster than std::exp2(), acceptable accuracy

- **rack::random::uniform()**: Uniform random generator
  - Range: 0.0 to 1.0 (exclusive)
  - Used for wow/flutter random waveforms
  - Thread-safe (per-module seed)
```

### Technical Resources

[Any academic papers, DSP books, tutorials referenced]

**Example:**
```markdown
- **Designing Audio Effect Plugins in C++** (Will Pirkle)
  - Chapter 10: Delay effects and feedback
  - Cubic interpolation formula for fractional delay
  - Feedback loop stability analysis

- **The Art of VA Filter Design** (Vadim Zavalishin)
  - TPT (Topology-Preserving Transform) filter design
  - State-variable filter implementation
  - Zero-delay feedback loops

- **VCV Rack SDK Documentation**
  - dsp.hpp header file documentation
  - Polyphony best practices
  - SIMD optimization patterns

- **Digital Audio Effects (DAFX)** - Online textbook
  - Delay line interpolation methods (linear, cubic, Lagrange)
  - Anti-aliasing strategies for nonlinear processing
  - Feedback system stability criteria
```

---

## Notes

[Any additional context, decisions made during research, open questions]

**Example:**
```markdown
- **Interpolation choice**: Chose cubic over Lagrange3rd for simplicity. Both provide smooth pitch-shifting, cubic is slightly faster.

- **Oversampling factor**: 2x chosen for tape saturation. Higher factors (4x, 8x) provide marginal improvement at 2-4x CPU cost.

- **Ping-pong implementation**: Dual delay lines with crossover feedback (L → R, R → L). Alternative is single buffer with alternating writes, but dual buffers are simpler.

- **External feedback normalization**: When EXT_FB is patched, internal feedback is disconnected. Use `inputs[EXT_FB_INPUT].isConnected()` to check.

- **Memory vs latency tradeoff**: 1-second buffer is generous (most delays use 250-500ms max). Could reduce to 500ms to halve memory usage.

- **1V/oct tracking**: Only active when FEEDBACK ≥ 90%. Below 90%, TIME_CV uses linear scaling (1V = 100ms). Above 90%, switches to exponential scaling (1V = 1 octave).

- **FREEZE gate behavior**: Uses Schmitt trigger (0.5V hysteresis) to prevent flickering on noisy gates. High = freeze (stop writes), Low = unfreeze (resume writes).

- **Polyphonic LFO phases**: Each channel gets independent wow/flutter phase for organic variation. Without this, all channels would modulate identically (boring).
```

---

## Implementation Checklist

[Verify all critical patterns from vcv-critical-patterns.md are addressed]

- [ ] **Voltages**: IN accepts ±5V audio, CV inputs use ±5V range, outputs generate ±5V
- [ ] **Polyphony**: `setChannels()` called after processing, `max(1, getChannels())` for channel count
- [ ] **Performance**: No expensive ops (div, sqrt, exp, sin, cos) in hot path, use approximations (exp2_taylor5)
- [ ] **Anti-aliasing**: Oversampling (2x) for tape saturation (nonlinear), interpolation for delay (discontinuous)
- [ ] **Coordinates**: All component positions use `mm2px()` (handled by panel-mockup skill)
- [ ] **Thread safety**: No mutexes in Module methods (guaranteed mutually exclusive by Rack)
- [ ] **Denormals**: Rack flushes denormals automatically, add small DC offset in feedback path if needed
- [ ] **Sample rate**: `onSampleRateChange()` recalculates buffer sizes, filter coefficients, LFO increments
- [ ] **Latency**: ~8 samples from oversampling (negligible), no compensation needed in Rack
- [ ] **Memory**: 12.5 MB for 16 channels (acceptable), consider lazy allocation if optimization needed

---

## Revision History

| Date | Version | Changes | Author |
|------|---------|---------|--------|
| [YYYY-MM-DD] | 1.0 | Initial DSP architecture | [Author] |

**Example:**
```markdown
| Date | Version | Changes | Author |
|------|---------|---------|--------|
| 2025-11-12 | 1.0 | Initial DSP architecture | Claude |
| 2025-11-13 | 1.1 | Changed interpolation from Lagrange3rd to cubic | User |
```

---

## Contract Status

**Status:** [Draft | Approved | Immutable]

**Approval Date:** [YYYY-MM-DD or "Pending"]

**Implementation Stage:** [0 = Research | 1 = Planning | 2+ = Implementation locked]

**Notes:**
- **Draft**: Still researching, architecture may change
- **Approved**: Ready for planning, changes require discussion
- **Immutable**: Implementation started, changes forbidden (would break contract)

**Example:**
```markdown
**Status:** Immutable

**Approval Date:** 2025-11-12

**Implementation Stage:** 4 (DSP stage - contract locked)

**Notes:**
Architecture locked after Stage 1 planning. No changes allowed during Stage 4 implementation. Any changes must create new version and restart from Stage 1.
```
